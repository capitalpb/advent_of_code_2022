# advent_of_code_2022

Advent of Code 2022 solutions in Rust.

Decided to pair this challenge with learning a new language this year. After
going through the [Rust Book](https://doc.rust-lang.org/stable/book/) this
seemed like a great way to practice the language and get used to writing it.
I'm sure I'll learn a lot along the way.

## Project Structure

I did the first two days as just functions in the `lib.rs` file to see what
kind of pieces I could factor out.

Created the `Solver` trait to act as an interface for each day's methods.
It was strange to work with wrapping the trait in a `Box<dyn Solver>` to allow
for returning any instance of the trait from a function as opposed to C# where
I am used to just returning the interface type itself. Once I wrapped my head
around this and the `Option` type around it, it was actually pretty intuitive
to write.

## Day 1

Not so bad. A nice little intro to trying to do some functional style
programming in the language. A bit trickier to wrap my head around some of the
methods coming from LINQ, especially having so specify types for things like
`sum()::<u32>`.

Part 2 was simple enough, but again I found I was missing things from LINQ,
like being able to chain all of the calls instead of separating the `sort()`
into it's own call and manipulating the data in place. I'd rather have some
type of `sorted()` iterator that allows this chaining and doesn't require a
mutable copy of the data.

## Day 2

Pretty simple today. I took the easy way out by hardcoding all 9 possible
outcomes in both scenarios. There is probably a more programatic way of doing
the calculation, but oh well. This way works and gets me 2 stars closer to
completion. I may revisit this one at a later date and find a more elegant
approach.

## Day 3

Wow. What feels like a pretty simple problem has turned into a convoluted
mess of code. I originally tried Part 1 by splitting the string in half and
converting each half into a `HashSet` so I could use the `intersection()`
method to find the shared character. This ended up turning into a mess of
dereferencing and odd code that was not pleasant to look at. I might just be
too lacking in my understanding of Rust at this point to pull that solution off
cleanly. Maybe I'll come back to it later and try again.

Using a simple for loop to check the characters turned out much nicer to look
at. Maybe my first solution was just too overcomplicated when the basics work.

Finding the `chunk()` method on the `Vec<>` type was also quite nice here.
Really saved some work in having to have another loop going through three
items at a time and keeping track of indexes.

## Day 4

This puzzle was pretty easy to come up with a solution for, but oh boy do I
hate how I wrote the code. The `parse_sections_to_u32s()` function is rather
verbose and returning a tuple of tuples seems a little gross, but it works.
This may be another one I come back to at the end and try to rework to cleaner
code with a better understanding of Rust.

The expressions I use in the two `filter()` calls are quite obnoxious as well.
Again, it works which is good, but I'd like to clean it up. There may be a way
to just turn them into simple ranges and use or write a function that checks if
a range contains or overlaps another. That sounds nice - I'll definitely be
coming back to this one. I think ideally I will just come back to the beginning
and go through each day again once I've completed all 25 and work on cleaning
one up with new knowledge or by researching cleaner solutions.

## Day 5

Holy cow. My initial run at this is just hideous code to me. It works, but oh
boy do I hate looking at it. I think a lot of this is probably just my
inexperience in the language showing. There are probably much easier and more
idiomatic ways of writing this one. This definitely solidifies my plan of
looping back around at the end and taking the time to clean each of these up.

## Day 6

I enjoyed this one. It was a nice simple break after the mess I wrote for Day 5. The `windows()` function that is akin to the `chunk()` function I used in
day 3 made this a quite simple and nice piece of code to write.

## Day 7

I struggled hard for the first time here. The test case was passing, but no
matter what I did I couldn't get the correct answer for the actual puzzle data.
After hand parsing my input file, and the `HashMap` generated by my code, I
finally realized that I was skipping over `dir` lines with the thought that
they'd just get added to the set when I add a file. What I didn't take into
account was directories that contained no files - only subdirectories. These
weren't being added at all. Once I fixed this issue, and started adding
directories to the set on `dir` lines instead of just when adding files, I got
the correct answer. Silly me. Gotta love spending a few hours on a silly little
slip-up. That's coding I guess.

I don't know that I necessarily love the code here, but again, I am excited to
come back through at the end and look into tidier solutions. I should stop
adding this comment every day now that I just know it's going to happen.

## Day 8

Not the most elegant code I've ever written, but it was simple and gets the job
done. Not much to say about this one. A nice simple break after day 7 though
that's for sure.

## Day 9

This one wasn't too tricky to solve, but writing the code to move the tail was
a bit of a process. At first I had a giant disgusting if/else if block covering
every possible combination of `x_diff` and `y_diff` being `-2`, `2`, `0`, `1`
or `-1`. It worked for star one, but I hated looking at it. Once I realized
star two could be written as the exact same code, just with one extra loop to
compare each knot to the previous as opposed to just two variables for the head
and tail, I took the opportunity to try and rewrite the code to be cleaner. I
ended up with the version I have now using `abs()` and division, which
significantly cut down on the code, and is much cleaner to look at. Then I just
popped my star two code into it's own function, added a parameter for the knot
count, and reused it for both stars. I enjoyed this one.

## Day 10

Tried this one a few different ways at first, and kept running into trouble.
Trying to process the CPU an instruction at a time and keeping one x variable
updated just wasn't working for me the way I wanted. Once I switched over to
just making a vector of `x`'s value at every cycle, solving the problems was
quite simple. This might not be the most efficient way of doing things, and I'm
sure with some more time I could have figured out a better way, but hey, it
works and it's quick enough for me.

## Day 11

Part one here wasn't too bad. The difficulty in getting it done wasn't the
logic, but working around the Rust language features that I'm not used to.
Specifically the borrow checker. What in my mind was a simple
`for monkey in monkies` loop became index based, because since I was borrowing
the variable in the loop, I couldn't reborrow it inside the loop to access
the other monkies in the array. I also had a second fight with the borrow
when performing the test on the items, because I couldn't reference the
`monkies` vector in an if statement, and then access it again inside that
statement. This just made me pop some values into values before I performed
the logic. Nothing too difficult, just some learning and reworking how I
instinctually wanted to write the code.

For part two I just had to straight up seek out the answer. The "hints", if
you even want to call them that, were so vague and my skills don't necessarily
lie in coming up with mathematical solutions like this, so I didn't even have
any idea of where to start. I tried increasing from `i32` to `i64`, and then
even up to `i128`, but the numbers were still too large. Having no idea how
to come up with the mathematical answer for this one, I just gave up and looked
up a solution. It made sense when I read it, but I never would have come up
with it on my own.

Also wanted to mention how much I hate my `Monkey::from()` function to parse
the input, but it works so whatever. Maybe that'll be a refactor in my second
pass.
