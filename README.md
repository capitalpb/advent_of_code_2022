# advent_of_code_2022
Advent of Code 2022 solutions in Rust.

Decided to pair this challenge with learning a new language this year. After
going through the [Rust Book](https://doc.rust-lang.org/stable/book/) this
seemed like a great way to practice the language and get used to writing it.
I'm sure I'll learn a lot along the way.

## Project Structure
I did the first two days as just functions in the `lib.rs` file to see what
kind of pieces I could factor out.

Created the `Solver` trait to act as an interface for each day's methods.
It was strange to work with wrapping the trait in a `Box<dyn Solver>` to allow
for returning any instance of the trait from a function as opposed to C# where
I am used to just returning the interface type itself. Once I wrapped my head
around this and the `Option` type around it, it was actually pretty intuitive
to write.

## Day 1
Not so bad. A nice little intro to trying to do some functional style
programming in the language. A bit trickier to wrap my head around some of the
methods coming from LINQ, especially having so specify types for things like
`sum()::<u32>`.

Part 2 was simple enough, but again I found I was missing things from LINQ,
like being able to chain all of the calls instead of separating the `sort()`
into it's own call and manipulating the data in place. I'd rather have some
type of `sorted()` iterator that allows this chaining and doesn't require a
mutable copy of the data.

## Day 2
Pretty simple today. I took the easy way out by hardcoding all 9 possible
outcomes in both scenarios. There is probably a more programatic way of doing
the calculation, but oh well. This way works and gets me 2 stars closer to
completion. I may revisit this one at a later date and find a more elegant
approach.

## Day 3
Wow. What feels like a pretty simple problem has turned into a convoluted
mess of code. I originally tried Part 1 by splitting the string in half and
converting each half into a `HashSet` so I could use the `intersection()`
method to find the shared character. This ended up turning into a mess of
dereferencing and odd code that was not pleasant to look at. I might just be
too lacking in my understanding of Rust at this point to pull that solution off
cleanly. Maybe I'll come back to it later and try again.

Using a simple for loop to check the characters turned out much nicer to look
at. Maybe my first solution was just too overcomplicated when the basics work.

Finding the `chunk()` method on the `Vec<>` type was also quite nice here.
Really saved some work in having to have another loop going through three
items at a time and keeping track of indexes.

## Day 4
This puzzle was pretty easy to come up with a solution for, but oh boy do I
hate how I wrote the code. The `parse_sections_to_u32s()` function is rather
verbose and returning a tuple of tuples seems a little gross, but it works.
This may be another one I come back to at the end and try to rework to cleaner
code with a better understanding of Rust.

The expressions I use in the two `filter()` calls are quite obnoxious as well.
Again, it works which is good, but I'd like to clean it up. There may be a way
to just turn them into simple ranges and use or write a function that checks if
a range contains or overlaps another. That sounds nice - I'll definitely be
coming back to this one. I think ideally I will just come back to the beginning
and go through each day again once I've completed all 25 and work on cleaning
one up with new knowledge or by researching cleaner solutions.

## Day 5
Holy cow. My initial run at this is just hideous code to me. It works, but oh
boy do I hate looking at it. I think a lot of this is probably just my
inexperience in the language showing. There are probably much easier and more
idiomatic ways of writing this one. This definitely solidifies my plan of
looping back around at the end and taking the time to clean each of these up.

## Day 6
I enjoyed this one. It was a nice simple break after the mess I wrote for Day
5. The `windows()` function that is akin to the `chunk()` function I used in
day 3 made this a quite simple and nice piece of code to write.

## Day 7
I struggled hard for the first time here. The test case was passing, but no
matter what I did I couldn't get the correct answer for the actual puzzle data.
After hand parsing my input file, and the `HashMap` generated by my code, I
finally realized that I was skipping over `dir` lines with the thought that
they'd just get added to the set when I add a file. What I didn't take into
account was directories that contained no files - only subdirectories. These
weren't being added at all. Once I fixed this issue, and started adding
directories to the set on `dir` lines instead of just when adding files, I got
the correct answer. Silly me. Gotta love spending a few hours on a silly little
slip-up. That's coding I guess.

I don't know that I necessarily love the code here, but again, I am excited to
come back through at the end and look into tidier solutions. I should stop
adding this comment every day now that I just know it's going to happen.

## Day 8
Not the most elegant code I've ever written, but it was simple and gets the job
done. Not much to say about this one. A nice simple break after day 7 though
that's for sure.